import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, parseEpochTimestamp as __parseEpochTimestamp, throwDefaultError, } from "@aws-sdk/smithy-client";
import { KMSServiceException as __BaseException } from "../models/KMSServiceException";
import { AlreadyExistsException, CloudHsmClusterInUseException, CloudHsmClusterInvalidConfigurationException, CloudHsmClusterNotActiveException, CloudHsmClusterNotFoundException, CloudHsmClusterNotRelatedException, CustomKeyStoreHasCMKsException, CustomKeyStoreInvalidStateException, CustomKeyStoreNameInUseException, CustomKeyStoreNotFoundException, DependencyTimeoutException, DisabledException, ExpiredImportTokenException, IncorrectKeyException, IncorrectKeyMaterialException, IncorrectTrustAnchorException, InvalidAliasNameException, InvalidArnException, InvalidCiphertextException, InvalidGrantIdException, InvalidGrantTokenException, InvalidImportTokenException, InvalidKeyUsageException, InvalidMarkerException, KeyUnavailableException, KMSInternalException, KMSInvalidMacException, KMSInvalidSignatureException, KMSInvalidStateException, LimitExceededException, MalformedPolicyDocumentException, NotFoundException, TagException, UnsupportedOperationException, XksKeyAlreadyInUseException, XksKeyInvalidConfigurationException, XksKeyNotFoundException, XksProxyIncorrectAuthenticationCredentialException, XksProxyInvalidConfigurationException, XksProxyInvalidResponseException, XksProxyUriEndpointInUseException, XksProxyUriInUseException, XksProxyUriUnreachableException, XksProxyVpcEndpointServiceInUseException, XksProxyVpcEndpointServiceInvalidConfigurationException, XksProxyVpcEndpointServiceNotFoundException, } from "../models/models_0";
export const serializeAws_json1_1CancelKeyDeletionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.CancelKeyDeletion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CancelKeyDeletionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ConnectCustomKeyStoreCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ConnectCustomKeyStore",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ConnectCustomKeyStoreRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateAliasCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.CreateAlias",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateAliasRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateCustomKeyStoreCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.CreateCustomKeyStore",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateCustomKeyStoreRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateGrantCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.CreateGrant",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateGrantRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.CreateKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DecryptCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.Decrypt",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DecryptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteAliasCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DeleteAlias",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteAliasRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteCustomKeyStoreCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DeleteCustomKeyStore",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteCustomKeyStoreRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteImportedKeyMaterialCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DeleteImportedKeyMaterial",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteImportedKeyMaterialRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DescribeCustomKeyStoresCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DescribeCustomKeyStores",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeCustomKeyStoresRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DescribeKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DescribeKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DescribeKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DisableKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DisableKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DisableKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DisableKeyRotationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DisableKeyRotation",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DisableKeyRotationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DisconnectCustomKeyStoreCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.DisconnectCustomKeyStore",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DisconnectCustomKeyStoreRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1EnableKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.EnableKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1EnableKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1EnableKeyRotationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.EnableKeyRotation",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1EnableKeyRotationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1EncryptCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.Encrypt",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1EncryptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GenerateDataKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GenerateDataKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GenerateDataKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GenerateDataKeyPairCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GenerateDataKeyPair",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GenerateDataKeyPairRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GenerateDataKeyPairWithoutPlaintextCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GenerateDataKeyPairWithoutPlaintext",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GenerateDataKeyPairWithoutPlaintextRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GenerateDataKeyWithoutPlaintextCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GenerateDataKeyWithoutPlaintext",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GenerateDataKeyWithoutPlaintextRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GenerateMacCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GenerateMac",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GenerateMacRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GenerateRandomCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GenerateRandom",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GenerateRandomRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetKeyPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GetKeyPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetKeyPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetKeyRotationStatusCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GetKeyRotationStatus",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetKeyRotationStatusRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetParametersForImportCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GetParametersForImport",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetParametersForImportRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetPublicKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.GetPublicKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetPublicKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ImportKeyMaterialCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ImportKeyMaterial",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ImportKeyMaterialRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListAliasesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ListAliases",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListAliasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListGrantsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ListGrants",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListGrantsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListKeyPoliciesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ListKeyPolicies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListKeyPoliciesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListKeysCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ListKeys",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListKeysRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListResourceTagsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ListResourceTags",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListResourceTagsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListRetirableGrantsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ListRetirableGrants",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListRetirableGrantsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1PutKeyPolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.PutKeyPolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutKeyPolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ReEncryptCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ReEncrypt",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ReEncryptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ReplicateKeyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ReplicateKey",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ReplicateKeyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1RetireGrantCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.RetireGrant",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RetireGrantRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1RevokeGrantCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.RevokeGrant",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RevokeGrantRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ScheduleKeyDeletionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.ScheduleKeyDeletion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ScheduleKeyDeletionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1SignCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.Sign",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1SignRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateAliasCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.UpdateAlias",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateAliasRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateCustomKeyStoreCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.UpdateCustomKeyStore",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateCustomKeyStoreRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateKeyDescriptionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.UpdateKeyDescription",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateKeyDescriptionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdatePrimaryRegionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.UpdatePrimaryRegion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdatePrimaryRegionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1VerifyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.Verify",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1VerifyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1VerifyMacCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "TrentService.VerifyMac",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1VerifyMacRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const deserializeAws_json1_1CancelKeyDeletionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CancelKeyDeletionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CancelKeyDeletionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CancelKeyDeletionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ConnectCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ConnectCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ConnectCustomKeyStoreResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ConnectCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await deserializeAws_json1_1CloudHsmClusterInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterNotActiveException":
        case "com.amazonaws.kms#CloudHsmClusterNotActiveException":
            throw await deserializeAws_json1_1CloudHsmClusterNotActiveExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateAliasCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.kms#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidAliasNameException":
        case "com.amazonaws.kms#InvalidAliasNameException":
            throw await deserializeAws_json1_1InvalidAliasNameExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateCustomKeyStoreResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInUseException":
        case "com.amazonaws.kms#CloudHsmClusterInUseException":
            throw await deserializeAws_json1_1CloudHsmClusterInUseExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await deserializeAws_json1_1CloudHsmClusterInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterNotActiveException":
        case "com.amazonaws.kms#CloudHsmClusterNotActiveException":
            throw await deserializeAws_json1_1CloudHsmClusterNotActiveExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterNotFoundException":
        case "com.amazonaws.kms#CloudHsmClusterNotFoundException":
            throw await deserializeAws_json1_1CloudHsmClusterNotFoundExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNameInUseException":
        case "com.amazonaws.kms#CustomKeyStoreNameInUseException":
            throw await deserializeAws_json1_1CustomKeyStoreNameInUseExceptionResponse(parsedOutput, context);
        case "IncorrectTrustAnchorException":
        case "com.amazonaws.kms#IncorrectTrustAnchorException":
            throw await deserializeAws_json1_1IncorrectTrustAnchorExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "XksProxyIncorrectAuthenticationCredentialException":
        case "com.amazonaws.kms#XksProxyIncorrectAuthenticationCredentialException":
            throw await deserializeAws_json1_1XksProxyIncorrectAuthenticationCredentialExceptionResponse(parsedOutput, context);
        case "XksProxyInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyInvalidConfigurationException":
            throw await deserializeAws_json1_1XksProxyInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "XksProxyInvalidResponseException":
        case "com.amazonaws.kms#XksProxyInvalidResponseException":
            throw await deserializeAws_json1_1XksProxyInvalidResponseExceptionResponse(parsedOutput, context);
        case "XksProxyUriEndpointInUseException":
        case "com.amazonaws.kms#XksProxyUriEndpointInUseException":
            throw await deserializeAws_json1_1XksProxyUriEndpointInUseExceptionResponse(parsedOutput, context);
        case "XksProxyUriInUseException":
        case "com.amazonaws.kms#XksProxyUriInUseException":
            throw await deserializeAws_json1_1XksProxyUriInUseExceptionResponse(parsedOutput, context);
        case "XksProxyUriUnreachableException":
        case "com.amazonaws.kms#XksProxyUriUnreachableException":
            throw await deserializeAws_json1_1XksProxyUriUnreachableExceptionResponse(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInUseException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInUseException":
            throw await deserializeAws_json1_1XksProxyVpcEndpointServiceInUseExceptionResponse(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInvalidConfigurationException":
            throw await deserializeAws_json1_1XksProxyVpcEndpointServiceInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "XksProxyVpcEndpointServiceNotFoundException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceNotFoundException":
            throw await deserializeAws_json1_1XksProxyVpcEndpointServiceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateGrantCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateGrantResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await deserializeAws_json1_1CloudHsmClusterInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.kms#MalformedPolicyDocumentException":
            throw await deserializeAws_json1_1MalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await deserializeAws_json1_1TagExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        case "XksKeyAlreadyInUseException":
        case "com.amazonaws.kms#XksKeyAlreadyInUseException":
            throw await deserializeAws_json1_1XksKeyAlreadyInUseExceptionResponse(parsedOutput, context);
        case "XksKeyInvalidConfigurationException":
        case "com.amazonaws.kms#XksKeyInvalidConfigurationException":
            throw await deserializeAws_json1_1XksKeyInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "XksKeyNotFoundException":
        case "com.amazonaws.kms#XksKeyNotFoundException":
            throw await deserializeAws_json1_1XksKeyNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DecryptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DecryptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DecryptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DecryptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "IncorrectKeyException":
        case "com.amazonaws.kms#IncorrectKeyException":
            throw await deserializeAws_json1_1IncorrectKeyExceptionResponse(parsedOutput, context);
        case "InvalidCiphertextException":
        case "com.amazonaws.kms#InvalidCiphertextException":
            throw await deserializeAws_json1_1InvalidCiphertextExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteAliasCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteCustomKeyStoreResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreHasCMKsException":
        case "com.amazonaws.kms#CustomKeyStoreHasCMKsException":
            throw await deserializeAws_json1_1CustomKeyStoreHasCMKsExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteImportedKeyMaterialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteImportedKeyMaterialCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteImportedKeyMaterialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DescribeCustomKeyStoresCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeCustomKeyStoresCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeCustomKeyStoresResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeCustomKeyStoresCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await deserializeAws_json1_1InvalidMarkerExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DescribeKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DescribeKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DescribeKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DescribeKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DisableKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DisableKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DisableKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DisableKeyRotationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DisableKeyRotationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DisableKeyRotationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DisconnectCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DisconnectCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DisconnectCustomKeyStoreResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DisconnectCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1EnableKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1EnableKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1EnableKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1EnableKeyRotationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1EnableKeyRotationCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1EnableKeyRotationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1EncryptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1EncryptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1EncryptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1EncryptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GenerateDataKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GenerateDataKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GenerateDataKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GenerateDataKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GenerateDataKeyPairCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GenerateDataKeyPairCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GenerateDataKeyPairResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GenerateDataKeyPairCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GenerateDataKeyPairWithoutPlaintextCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GenerateDataKeyPairWithoutPlaintextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GenerateDataKeyPairWithoutPlaintextResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GenerateDataKeyPairWithoutPlaintextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GenerateDataKeyWithoutPlaintextCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GenerateDataKeyWithoutPlaintextCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GenerateDataKeyWithoutPlaintextResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GenerateDataKeyWithoutPlaintextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GenerateMacCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GenerateMacCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GenerateMacResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GenerateMacCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GenerateRandomCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GenerateRandomCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GenerateRandomResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GenerateRandomCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetKeyPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetKeyPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetKeyPolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetKeyPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetKeyRotationStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetKeyRotationStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetKeyRotationStatusResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetKeyRotationStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetParametersForImportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetParametersForImportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetParametersForImportResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetParametersForImportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetPublicKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetPublicKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ImportKeyMaterialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ImportKeyMaterialCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ImportKeyMaterialResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ImportKeyMaterialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "ExpiredImportTokenException":
        case "com.amazonaws.kms#ExpiredImportTokenException":
            throw await deserializeAws_json1_1ExpiredImportTokenExceptionResponse(parsedOutput, context);
        case "IncorrectKeyMaterialException":
        case "com.amazonaws.kms#IncorrectKeyMaterialException":
            throw await deserializeAws_json1_1IncorrectKeyMaterialExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidCiphertextException":
        case "com.amazonaws.kms#InvalidCiphertextException":
            throw await deserializeAws_json1_1InvalidCiphertextExceptionResponse(parsedOutput, context);
        case "InvalidImportTokenException":
        case "com.amazonaws.kms#InvalidImportTokenException":
            throw await deserializeAws_json1_1InvalidImportTokenExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListAliasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListAliasesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await deserializeAws_json1_1InvalidMarkerExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListGrantsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListGrantsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListGrantsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListGrantsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidGrantIdException":
        case "com.amazonaws.kms#InvalidGrantIdException":
            throw await deserializeAws_json1_1InvalidGrantIdExceptionResponse(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await deserializeAws_json1_1InvalidMarkerExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListKeyPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListKeyPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListKeyPoliciesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListKeyPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListKeysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListKeysResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await deserializeAws_json1_1InvalidMarkerExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListResourceTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListResourceTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListResourceTagsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListResourceTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await deserializeAws_json1_1InvalidMarkerExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListRetirableGrantsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListRetirableGrantsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListGrantsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListRetirableGrantsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidMarkerException":
        case "com.amazonaws.kms#InvalidMarkerException":
            throw await deserializeAws_json1_1InvalidMarkerExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1PutKeyPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutKeyPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1PutKeyPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.kms#MalformedPolicyDocumentException":
            throw await deserializeAws_json1_1MalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ReEncryptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ReEncryptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ReEncryptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ReEncryptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "IncorrectKeyException":
        case "com.amazonaws.kms#IncorrectKeyException":
            throw await deserializeAws_json1_1IncorrectKeyExceptionResponse(parsedOutput, context);
        case "InvalidCiphertextException":
        case "com.amazonaws.kms#InvalidCiphertextException":
            throw await deserializeAws_json1_1InvalidCiphertextExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ReplicateKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ReplicateKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ReplicateKeyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ReplicateKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.kms#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.kms#MalformedPolicyDocumentException":
            throw await deserializeAws_json1_1MalformedPolicyDocumentExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await deserializeAws_json1_1TagExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1RetireGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RetireGrantCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1RetireGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidGrantIdException":
        case "com.amazonaws.kms#InvalidGrantIdException":
            throw await deserializeAws_json1_1InvalidGrantIdExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1RevokeGrantCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RevokeGrantCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1RevokeGrantCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "InvalidGrantIdException":
        case "com.amazonaws.kms#InvalidGrantIdException":
            throw await deserializeAws_json1_1InvalidGrantIdExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ScheduleKeyDeletionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ScheduleKeyDeletionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ScheduleKeyDeletionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ScheduleKeyDeletionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1SignCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1SignCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1SignResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1SignCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await deserializeAws_json1_1TagExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "TagException":
        case "com.amazonaws.kms#TagException":
            throw await deserializeAws_json1_1TagExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateAliasCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.kms#LimitExceededException":
            throw await deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateCustomKeyStoreCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateCustomKeyStoreCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateCustomKeyStoreResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateCustomKeyStoreCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CloudHsmClusterInvalidConfigurationException":
        case "com.amazonaws.kms#CloudHsmClusterInvalidConfigurationException":
            throw await deserializeAws_json1_1CloudHsmClusterInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterNotActiveException":
        case "com.amazonaws.kms#CloudHsmClusterNotActiveException":
            throw await deserializeAws_json1_1CloudHsmClusterNotActiveExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterNotFoundException":
        case "com.amazonaws.kms#CloudHsmClusterNotFoundException":
            throw await deserializeAws_json1_1CloudHsmClusterNotFoundExceptionResponse(parsedOutput, context);
        case "CloudHsmClusterNotRelatedException":
        case "com.amazonaws.kms#CloudHsmClusterNotRelatedException":
            throw await deserializeAws_json1_1CloudHsmClusterNotRelatedExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreInvalidStateException":
        case "com.amazonaws.kms#CustomKeyStoreInvalidStateException":
            throw await deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNameInUseException":
        case "com.amazonaws.kms#CustomKeyStoreNameInUseException":
            throw await deserializeAws_json1_1CustomKeyStoreNameInUseExceptionResponse(parsedOutput, context);
        case "CustomKeyStoreNotFoundException":
        case "com.amazonaws.kms#CustomKeyStoreNotFoundException":
            throw await deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "XksProxyIncorrectAuthenticationCredentialException":
        case "com.amazonaws.kms#XksProxyIncorrectAuthenticationCredentialException":
            throw await deserializeAws_json1_1XksProxyIncorrectAuthenticationCredentialExceptionResponse(parsedOutput, context);
        case "XksProxyInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyInvalidConfigurationException":
            throw await deserializeAws_json1_1XksProxyInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "XksProxyInvalidResponseException":
        case "com.amazonaws.kms#XksProxyInvalidResponseException":
            throw await deserializeAws_json1_1XksProxyInvalidResponseExceptionResponse(parsedOutput, context);
        case "XksProxyUriEndpointInUseException":
        case "com.amazonaws.kms#XksProxyUriEndpointInUseException":
            throw await deserializeAws_json1_1XksProxyUriEndpointInUseExceptionResponse(parsedOutput, context);
        case "XksProxyUriInUseException":
        case "com.amazonaws.kms#XksProxyUriInUseException":
            throw await deserializeAws_json1_1XksProxyUriInUseExceptionResponse(parsedOutput, context);
        case "XksProxyUriUnreachableException":
        case "com.amazonaws.kms#XksProxyUriUnreachableException":
            throw await deserializeAws_json1_1XksProxyUriUnreachableExceptionResponse(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInUseException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInUseException":
            throw await deserializeAws_json1_1XksProxyVpcEndpointServiceInUseExceptionResponse(parsedOutput, context);
        case "XksProxyVpcEndpointServiceInvalidConfigurationException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceInvalidConfigurationException":
            throw await deserializeAws_json1_1XksProxyVpcEndpointServiceInvalidConfigurationExceptionResponse(parsedOutput, context);
        case "XksProxyVpcEndpointServiceNotFoundException":
        case "com.amazonaws.kms#XksProxyVpcEndpointServiceNotFoundException":
            throw await deserializeAws_json1_1XksProxyVpcEndpointServiceNotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateKeyDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateKeyDescriptionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateKeyDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdatePrimaryRegionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdatePrimaryRegionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdatePrimaryRegionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.kms#InvalidArnException":
            throw await deserializeAws_json1_1InvalidArnExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.kms#UnsupportedOperationException":
            throw await deserializeAws_json1_1UnsupportedOperationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1VerifyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1VerifyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1VerifyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1VerifyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DependencyTimeoutException":
        case "com.amazonaws.kms#DependencyTimeoutException":
            throw await deserializeAws_json1_1DependencyTimeoutExceptionResponse(parsedOutput, context);
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidSignatureException":
        case "com.amazonaws.kms#KMSInvalidSignatureException":
            throw await deserializeAws_json1_1KMSInvalidSignatureExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1VerifyMacCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1VerifyMacCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1VerifyMacResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1VerifyMacCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DisabledException":
        case "com.amazonaws.kms#DisabledException":
            throw await deserializeAws_json1_1DisabledExceptionResponse(parsedOutput, context);
        case "InvalidGrantTokenException":
        case "com.amazonaws.kms#InvalidGrantTokenException":
            throw await deserializeAws_json1_1InvalidGrantTokenExceptionResponse(parsedOutput, context);
        case "InvalidKeyUsageException":
        case "com.amazonaws.kms#InvalidKeyUsageException":
            throw await deserializeAws_json1_1InvalidKeyUsageExceptionResponse(parsedOutput, context);
        case "KMSInternalException":
        case "com.amazonaws.kms#KMSInternalException":
            throw await deserializeAws_json1_1KMSInternalExceptionResponse(parsedOutput, context);
        case "KMSInvalidMacException":
        case "com.amazonaws.kms#KMSInvalidMacException":
            throw await deserializeAws_json1_1KMSInvalidMacExceptionResponse(parsedOutput, context);
        case "KMSInvalidStateException":
        case "com.amazonaws.kms#KMSInvalidStateException":
            throw await deserializeAws_json1_1KMSInvalidStateExceptionResponse(parsedOutput, context);
        case "KeyUnavailableException":
        case "com.amazonaws.kms#KeyUnavailableException":
            throw await deserializeAws_json1_1KeyUnavailableExceptionResponse(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.kms#NotFoundException":
            throw await deserializeAws_json1_1NotFoundExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1AlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AlreadyExistsException(body, context);
    const exception = new AlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CloudHsmClusterInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CloudHsmClusterInUseException(body, context);
    const exception = new CloudHsmClusterInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CloudHsmClusterInvalidConfigurationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CloudHsmClusterInvalidConfigurationException(body, context);
    const exception = new CloudHsmClusterInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CloudHsmClusterNotActiveExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CloudHsmClusterNotActiveException(body, context);
    const exception = new CloudHsmClusterNotActiveException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CloudHsmClusterNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CloudHsmClusterNotFoundException(body, context);
    const exception = new CloudHsmClusterNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CloudHsmClusterNotRelatedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CloudHsmClusterNotRelatedException(body, context);
    const exception = new CloudHsmClusterNotRelatedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CustomKeyStoreHasCMKsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CustomKeyStoreHasCMKsException(body, context);
    const exception = new CustomKeyStoreHasCMKsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CustomKeyStoreInvalidStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CustomKeyStoreInvalidStateException(body, context);
    const exception = new CustomKeyStoreInvalidStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CustomKeyStoreNameInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CustomKeyStoreNameInUseException(body, context);
    const exception = new CustomKeyStoreNameInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CustomKeyStoreNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CustomKeyStoreNotFoundException(body, context);
    const exception = new CustomKeyStoreNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1DependencyTimeoutExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DependencyTimeoutException(body, context);
    const exception = new DependencyTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1DisabledExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1DisabledException(body, context);
    const exception = new DisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ExpiredImportTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ExpiredImportTokenException(body, context);
    const exception = new ExpiredImportTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IncorrectKeyExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IncorrectKeyException(body, context);
    const exception = new IncorrectKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IncorrectKeyMaterialExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IncorrectKeyMaterialException(body, context);
    const exception = new IncorrectKeyMaterialException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IncorrectTrustAnchorExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IncorrectTrustAnchorException(body, context);
    const exception = new IncorrectTrustAnchorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidAliasNameExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidAliasNameException(body, context);
    const exception = new InvalidAliasNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidArnExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidArnException(body, context);
    const exception = new InvalidArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidCiphertextExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidCiphertextException(body, context);
    const exception = new InvalidCiphertextException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidGrantIdExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidGrantIdException(body, context);
    const exception = new InvalidGrantIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidGrantTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidGrantTokenException(body, context);
    const exception = new InvalidGrantTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidImportTokenExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidImportTokenException(body, context);
    const exception = new InvalidImportTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidKeyUsageExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidKeyUsageException(body, context);
    const exception = new InvalidKeyUsageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidMarkerExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidMarkerException(body, context);
    const exception = new InvalidMarkerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1KeyUnavailableExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1KeyUnavailableException(body, context);
    const exception = new KeyUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1KMSInternalExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1KMSInternalException(body, context);
    const exception = new KMSInternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1KMSInvalidMacExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1KMSInvalidMacException(body, context);
    const exception = new KMSInvalidMacException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1KMSInvalidSignatureExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1KMSInvalidSignatureException(body, context);
    const exception = new KMSInvalidSignatureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1KMSInvalidStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1KMSInvalidStateException(body, context);
    const exception = new KMSInvalidStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1LimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1LimitExceededException(body, context);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1MalformedPolicyDocumentExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1MalformedPolicyDocumentException(body, context);
    const exception = new MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1NotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1NotFoundException(body, context);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1TagExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1TagException(body, context);
    const exception = new TagException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1UnsupportedOperationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1UnsupportedOperationException(body, context);
    const exception = new UnsupportedOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksKeyAlreadyInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksKeyAlreadyInUseException(body, context);
    const exception = new XksKeyAlreadyInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksKeyInvalidConfigurationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksKeyInvalidConfigurationException(body, context);
    const exception = new XksKeyInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksKeyNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksKeyNotFoundException(body, context);
    const exception = new XksKeyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyIncorrectAuthenticationCredentialExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyIncorrectAuthenticationCredentialException(body, context);
    const exception = new XksProxyIncorrectAuthenticationCredentialException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyInvalidConfigurationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyInvalidConfigurationException(body, context);
    const exception = new XksProxyInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyInvalidResponseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyInvalidResponseException(body, context);
    const exception = new XksProxyInvalidResponseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyUriEndpointInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyUriEndpointInUseException(body, context);
    const exception = new XksProxyUriEndpointInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyUriInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyUriInUseException(body, context);
    const exception = new XksProxyUriInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyUriUnreachableExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyUriUnreachableException(body, context);
    const exception = new XksProxyUriUnreachableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyVpcEndpointServiceInUseExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyVpcEndpointServiceInUseException(body, context);
    const exception = new XksProxyVpcEndpointServiceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyVpcEndpointServiceInvalidConfigurationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyVpcEndpointServiceInvalidConfigurationException(body, context);
    const exception = new XksProxyVpcEndpointServiceInvalidConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1XksProxyVpcEndpointServiceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1XksProxyVpcEndpointServiceNotFoundException(body, context);
    const exception = new XksProxyVpcEndpointServiceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const serializeAws_json1_1CancelKeyDeletionRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1ConnectCustomKeyStoreRequest = (input, context) => {
    return {
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
    };
};
const serializeAws_json1_1CreateAliasRequest = (input, context) => {
    return {
        ...(input.AliasName != null && { AliasName: input.AliasName }),
        ...(input.TargetKeyId != null && { TargetKeyId: input.TargetKeyId }),
    };
};
const serializeAws_json1_1CreateCustomKeyStoreRequest = (input, context) => {
    return {
        ...(input.CloudHsmClusterId != null && { CloudHsmClusterId: input.CloudHsmClusterId }),
        ...(input.CustomKeyStoreName != null && { CustomKeyStoreName: input.CustomKeyStoreName }),
        ...(input.CustomKeyStoreType != null && { CustomKeyStoreType: input.CustomKeyStoreType }),
        ...(input.KeyStorePassword != null && { KeyStorePassword: input.KeyStorePassword }),
        ...(input.TrustAnchorCertificate != null && { TrustAnchorCertificate: input.TrustAnchorCertificate }),
        ...(input.XksProxyAuthenticationCredential != null && {
            XksProxyAuthenticationCredential: serializeAws_json1_1XksProxyAuthenticationCredentialType(input.XksProxyAuthenticationCredential, context),
        }),
        ...(input.XksProxyConnectivity != null && { XksProxyConnectivity: input.XksProxyConnectivity }),
        ...(input.XksProxyUriEndpoint != null && { XksProxyUriEndpoint: input.XksProxyUriEndpoint }),
        ...(input.XksProxyUriPath != null && { XksProxyUriPath: input.XksProxyUriPath }),
        ...(input.XksProxyVpcEndpointServiceName != null && {
            XksProxyVpcEndpointServiceName: input.XksProxyVpcEndpointServiceName,
        }),
    };
};
const serializeAws_json1_1CreateGrantRequest = (input, context) => {
    return {
        ...(input.Constraints != null && { Constraints: serializeAws_json1_1GrantConstraints(input.Constraints, context) }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.GranteePrincipal != null && { GranteePrincipal: input.GranteePrincipal }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Operations != null && { Operations: serializeAws_json1_1GrantOperationList(input.Operations, context) }),
        ...(input.RetiringPrincipal != null && { RetiringPrincipal: input.RetiringPrincipal }),
    };
};
const serializeAws_json1_1CreateKeyRequest = (input, context) => {
    return {
        ...(input.BypassPolicyLockoutSafetyCheck != null && {
            BypassPolicyLockoutSafetyCheck: input.BypassPolicyLockoutSafetyCheck,
        }),
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
        ...(input.CustomerMasterKeySpec != null && { CustomerMasterKeySpec: input.CustomerMasterKeySpec }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.KeySpec != null && { KeySpec: input.KeySpec }),
        ...(input.KeyUsage != null && { KeyUsage: input.KeyUsage }),
        ...(input.MultiRegion != null && { MultiRegion: input.MultiRegion }),
        ...(input.Origin != null && { Origin: input.Origin }),
        ...(input.Policy != null && { Policy: input.Policy }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
        ...(input.XksKeyId != null && { XksKeyId: input.XksKeyId }),
    };
};
const serializeAws_json1_1DecryptRequest = (input, context) => {
    return {
        ...(input.CiphertextBlob != null && { CiphertextBlob: context.base64Encoder(input.CiphertextBlob) }),
        ...(input.EncryptionAlgorithm != null && { EncryptionAlgorithm: input.EncryptionAlgorithm }),
        ...(input.EncryptionContext != null && {
            EncryptionContext: serializeAws_json1_1EncryptionContextType(input.EncryptionContext, context),
        }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1DeleteAliasRequest = (input, context) => {
    return {
        ...(input.AliasName != null && { AliasName: input.AliasName }),
    };
};
const serializeAws_json1_1DeleteCustomKeyStoreRequest = (input, context) => {
    return {
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
    };
};
const serializeAws_json1_1DeleteImportedKeyMaterialRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1DescribeCustomKeyStoresRequest = (input, context) => {
    return {
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
        ...(input.CustomKeyStoreName != null && { CustomKeyStoreName: input.CustomKeyStoreName }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
    };
};
const serializeAws_json1_1DescribeKeyRequest = (input, context) => {
    return {
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1DisableKeyRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1DisableKeyRotationRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1DisconnectCustomKeyStoreRequest = (input, context) => {
    return {
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
    };
};
const serializeAws_json1_1EnableKeyRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1EnableKeyRotationRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1EncryptionContextType = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1EncryptRequest = (input, context) => {
    return {
        ...(input.EncryptionAlgorithm != null && { EncryptionAlgorithm: input.EncryptionAlgorithm }),
        ...(input.EncryptionContext != null && {
            EncryptionContext: serializeAws_json1_1EncryptionContextType(input.EncryptionContext, context),
        }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Plaintext != null && { Plaintext: context.base64Encoder(input.Plaintext) }),
    };
};
const serializeAws_json1_1GenerateDataKeyPairRequest = (input, context) => {
    return {
        ...(input.EncryptionContext != null && {
            EncryptionContext: serializeAws_json1_1EncryptionContextType(input.EncryptionContext, context),
        }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.KeyPairSpec != null && { KeyPairSpec: input.KeyPairSpec }),
    };
};
const serializeAws_json1_1GenerateDataKeyPairWithoutPlaintextRequest = (input, context) => {
    return {
        ...(input.EncryptionContext != null && {
            EncryptionContext: serializeAws_json1_1EncryptionContextType(input.EncryptionContext, context),
        }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.KeyPairSpec != null && { KeyPairSpec: input.KeyPairSpec }),
    };
};
const serializeAws_json1_1GenerateDataKeyRequest = (input, context) => {
    return {
        ...(input.EncryptionContext != null && {
            EncryptionContext: serializeAws_json1_1EncryptionContextType(input.EncryptionContext, context),
        }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.KeySpec != null && { KeySpec: input.KeySpec }),
        ...(input.NumberOfBytes != null && { NumberOfBytes: input.NumberOfBytes }),
    };
};
const serializeAws_json1_1GenerateDataKeyWithoutPlaintextRequest = (input, context) => {
    return {
        ...(input.EncryptionContext != null && {
            EncryptionContext: serializeAws_json1_1EncryptionContextType(input.EncryptionContext, context),
        }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.KeySpec != null && { KeySpec: input.KeySpec }),
        ...(input.NumberOfBytes != null && { NumberOfBytes: input.NumberOfBytes }),
    };
};
const serializeAws_json1_1GenerateMacRequest = (input, context) => {
    return {
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.MacAlgorithm != null && { MacAlgorithm: input.MacAlgorithm }),
        ...(input.Message != null && { Message: context.base64Encoder(input.Message) }),
    };
};
const serializeAws_json1_1GenerateRandomRequest = (input, context) => {
    return {
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
        ...(input.NumberOfBytes != null && { NumberOfBytes: input.NumberOfBytes }),
    };
};
const serializeAws_json1_1GetKeyPolicyRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.PolicyName != null && { PolicyName: input.PolicyName }),
    };
};
const serializeAws_json1_1GetKeyRotationStatusRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1GetParametersForImportRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.WrappingAlgorithm != null && { WrappingAlgorithm: input.WrappingAlgorithm }),
        ...(input.WrappingKeySpec != null && { WrappingKeySpec: input.WrappingKeySpec }),
    };
};
const serializeAws_json1_1GetPublicKeyRequest = (input, context) => {
    return {
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1GrantConstraints = (input, context) => {
    return {
        ...(input.EncryptionContextEquals != null && {
            EncryptionContextEquals: serializeAws_json1_1EncryptionContextType(input.EncryptionContextEquals, context),
        }),
        ...(input.EncryptionContextSubset != null && {
            EncryptionContextSubset: serializeAws_json1_1EncryptionContextType(input.EncryptionContextSubset, context),
        }),
    };
};
const serializeAws_json1_1GrantOperationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1GrantTokenList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1ImportKeyMaterialRequest = (input, context) => {
    return {
        ...(input.EncryptedKeyMaterial != null && {
            EncryptedKeyMaterial: context.base64Encoder(input.EncryptedKeyMaterial),
        }),
        ...(input.ExpirationModel != null && { ExpirationModel: input.ExpirationModel }),
        ...(input.ImportToken != null && { ImportToken: context.base64Encoder(input.ImportToken) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.ValidTo != null && { ValidTo: Math.round(input.ValidTo.getTime() / 1000) }),
    };
};
const serializeAws_json1_1ListAliasesRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
    };
};
const serializeAws_json1_1ListGrantsRequest = (input, context) => {
    return {
        ...(input.GrantId != null && { GrantId: input.GrantId }),
        ...(input.GranteePrincipal != null && { GranteePrincipal: input.GranteePrincipal }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
    };
};
const serializeAws_json1_1ListKeyPoliciesRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
    };
};
const serializeAws_json1_1ListKeysRequest = (input, context) => {
    return {
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
    };
};
const serializeAws_json1_1ListResourceTagsRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
    };
};
const serializeAws_json1_1ListRetirableGrantsRequest = (input, context) => {
    return {
        ...(input.Limit != null && { Limit: input.Limit }),
        ...(input.Marker != null && { Marker: input.Marker }),
        ...(input.RetiringPrincipal != null && { RetiringPrincipal: input.RetiringPrincipal }),
    };
};
const serializeAws_json1_1PutKeyPolicyRequest = (input, context) => {
    return {
        ...(input.BypassPolicyLockoutSafetyCheck != null && {
            BypassPolicyLockoutSafetyCheck: input.BypassPolicyLockoutSafetyCheck,
        }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Policy != null && { Policy: input.Policy }),
        ...(input.PolicyName != null && { PolicyName: input.PolicyName }),
    };
};
const serializeAws_json1_1ReEncryptRequest = (input, context) => {
    return {
        ...(input.CiphertextBlob != null && { CiphertextBlob: context.base64Encoder(input.CiphertextBlob) }),
        ...(input.DestinationEncryptionAlgorithm != null && {
            DestinationEncryptionAlgorithm: input.DestinationEncryptionAlgorithm,
        }),
        ...(input.DestinationEncryptionContext != null && {
            DestinationEncryptionContext: serializeAws_json1_1EncryptionContextType(input.DestinationEncryptionContext, context),
        }),
        ...(input.DestinationKeyId != null && { DestinationKeyId: input.DestinationKeyId }),
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.SourceEncryptionAlgorithm != null && { SourceEncryptionAlgorithm: input.SourceEncryptionAlgorithm }),
        ...(input.SourceEncryptionContext != null && {
            SourceEncryptionContext: serializeAws_json1_1EncryptionContextType(input.SourceEncryptionContext, context),
        }),
        ...(input.SourceKeyId != null && { SourceKeyId: input.SourceKeyId }),
    };
};
const serializeAws_json1_1ReplicateKeyRequest = (input, context) => {
    return {
        ...(input.BypassPolicyLockoutSafetyCheck != null && {
            BypassPolicyLockoutSafetyCheck: input.BypassPolicyLockoutSafetyCheck,
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Policy != null && { Policy: input.Policy }),
        ...(input.ReplicaRegion != null && { ReplicaRegion: input.ReplicaRegion }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
    };
};
const serializeAws_json1_1RetireGrantRequest = (input, context) => {
    return {
        ...(input.GrantId != null && { GrantId: input.GrantId }),
        ...(input.GrantToken != null && { GrantToken: input.GrantToken }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1RevokeGrantRequest = (input, context) => {
    return {
        ...(input.GrantId != null && { GrantId: input.GrantId }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1ScheduleKeyDeletionRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.PendingWindowInDays != null && { PendingWindowInDays: input.PendingWindowInDays }),
    };
};
const serializeAws_json1_1SignRequest = (input, context) => {
    return {
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Message != null && { Message: context.base64Encoder(input.Message) }),
        ...(input.MessageType != null && { MessageType: input.MessageType }),
        ...(input.SigningAlgorithm != null && { SigningAlgorithm: input.SigningAlgorithm }),
    };
};
const serializeAws_json1_1Tag = (input, context) => {
    return {
        ...(input.TagKey != null && { TagKey: input.TagKey }),
        ...(input.TagValue != null && { TagValue: input.TagValue }),
    };
};
const serializeAws_json1_1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Tag(entry, context);
    });
};
const serializeAws_json1_1TagResourceRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
    };
};
const serializeAws_json1_1UntagResourceRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.TagKeys != null && { TagKeys: serializeAws_json1_1TagKeyList(input.TagKeys, context) }),
    };
};
const serializeAws_json1_1UpdateAliasRequest = (input, context) => {
    return {
        ...(input.AliasName != null && { AliasName: input.AliasName }),
        ...(input.TargetKeyId != null && { TargetKeyId: input.TargetKeyId }),
    };
};
const serializeAws_json1_1UpdateCustomKeyStoreRequest = (input, context) => {
    return {
        ...(input.CloudHsmClusterId != null && { CloudHsmClusterId: input.CloudHsmClusterId }),
        ...(input.CustomKeyStoreId != null && { CustomKeyStoreId: input.CustomKeyStoreId }),
        ...(input.KeyStorePassword != null && { KeyStorePassword: input.KeyStorePassword }),
        ...(input.NewCustomKeyStoreName != null && { NewCustomKeyStoreName: input.NewCustomKeyStoreName }),
        ...(input.XksProxyAuthenticationCredential != null && {
            XksProxyAuthenticationCredential: serializeAws_json1_1XksProxyAuthenticationCredentialType(input.XksProxyAuthenticationCredential, context),
        }),
        ...(input.XksProxyConnectivity != null && { XksProxyConnectivity: input.XksProxyConnectivity }),
        ...(input.XksProxyUriEndpoint != null && { XksProxyUriEndpoint: input.XksProxyUriEndpoint }),
        ...(input.XksProxyUriPath != null && { XksProxyUriPath: input.XksProxyUriPath }),
        ...(input.XksProxyVpcEndpointServiceName != null && {
            XksProxyVpcEndpointServiceName: input.XksProxyVpcEndpointServiceName,
        }),
    };
};
const serializeAws_json1_1UpdateKeyDescriptionRequest = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
    };
};
const serializeAws_json1_1UpdatePrimaryRegionRequest = (input, context) => {
    return {
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.PrimaryRegion != null && { PrimaryRegion: input.PrimaryRegion }),
    };
};
const serializeAws_json1_1VerifyMacRequest = (input, context) => {
    return {
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Mac != null && { Mac: context.base64Encoder(input.Mac) }),
        ...(input.MacAlgorithm != null && { MacAlgorithm: input.MacAlgorithm }),
        ...(input.Message != null && { Message: context.base64Encoder(input.Message) }),
    };
};
const serializeAws_json1_1VerifyRequest = (input, context) => {
    return {
        ...(input.GrantTokens != null && { GrantTokens: serializeAws_json1_1GrantTokenList(input.GrantTokens, context) }),
        ...(input.KeyId != null && { KeyId: input.KeyId }),
        ...(input.Message != null && { Message: context.base64Encoder(input.Message) }),
        ...(input.MessageType != null && { MessageType: input.MessageType }),
        ...(input.Signature != null && { Signature: context.base64Encoder(input.Signature) }),
        ...(input.SigningAlgorithm != null && { SigningAlgorithm: input.SigningAlgorithm }),
    };
};
const serializeAws_json1_1XksProxyAuthenticationCredentialType = (input, context) => {
    return {
        ...(input.AccessKeyId != null && { AccessKeyId: input.AccessKeyId }),
        ...(input.RawSecretAccessKey != null && { RawSecretAccessKey: input.RawSecretAccessKey }),
    };
};
const deserializeAws_json1_1AliasList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1AliasListEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1AliasListEntry = (output, context) => {
    return {
        AliasArn: __expectString(output.AliasArn),
        AliasName: __expectString(output.AliasName),
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        LastUpdatedDate: output.LastUpdatedDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdatedDate)))
            : undefined,
        TargetKeyId: __expectString(output.TargetKeyId),
    };
};
const deserializeAws_json1_1AlreadyExistsException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CancelKeyDeletionResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
    };
};
const deserializeAws_json1_1CloudHsmClusterInUseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CloudHsmClusterInvalidConfigurationException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CloudHsmClusterNotActiveException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CloudHsmClusterNotFoundException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CloudHsmClusterNotRelatedException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1ConnectCustomKeyStoreResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateCustomKeyStoreResponse = (output, context) => {
    return {
        CustomKeyStoreId: __expectString(output.CustomKeyStoreId),
    };
};
const deserializeAws_json1_1CreateGrantResponse = (output, context) => {
    return {
        GrantId: __expectString(output.GrantId),
        GrantToken: __expectString(output.GrantToken),
    };
};
const deserializeAws_json1_1CreateKeyResponse = (output, context) => {
    return {
        KeyMetadata: output.KeyMetadata != null ? deserializeAws_json1_1KeyMetadata(output.KeyMetadata, context) : undefined,
    };
};
const deserializeAws_json1_1CustomKeyStoreHasCMKsException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CustomKeyStoreInvalidStateException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CustomKeyStoreNameInUseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CustomKeyStoreNotFoundException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1CustomKeyStoresList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CustomKeyStoresListEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CustomKeyStoresListEntry = (output, context) => {
    return {
        CloudHsmClusterId: __expectString(output.CloudHsmClusterId),
        ConnectionErrorCode: __expectString(output.ConnectionErrorCode),
        ConnectionState: __expectString(output.ConnectionState),
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        CustomKeyStoreId: __expectString(output.CustomKeyStoreId),
        CustomKeyStoreName: __expectString(output.CustomKeyStoreName),
        CustomKeyStoreType: __expectString(output.CustomKeyStoreType),
        TrustAnchorCertificate: __expectString(output.TrustAnchorCertificate),
        XksProxyConfiguration: output.XksProxyConfiguration != null
            ? deserializeAws_json1_1XksProxyConfigurationType(output.XksProxyConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_1DecryptResponse = (output, context) => {
    return {
        EncryptionAlgorithm: __expectString(output.EncryptionAlgorithm),
        KeyId: __expectString(output.KeyId),
        Plaintext: output.Plaintext != null ? context.base64Decoder(output.Plaintext) : undefined,
    };
};
const deserializeAws_json1_1DeleteCustomKeyStoreResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DependencyTimeoutException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1DescribeCustomKeyStoresResponse = (output, context) => {
    return {
        CustomKeyStores: output.CustomKeyStores != null
            ? deserializeAws_json1_1CustomKeyStoresList(output.CustomKeyStores, context)
            : undefined,
        NextMarker: __expectString(output.NextMarker),
        Truncated: __expectBoolean(output.Truncated),
    };
};
const deserializeAws_json1_1DescribeKeyResponse = (output, context) => {
    return {
        KeyMetadata: output.KeyMetadata != null ? deserializeAws_json1_1KeyMetadata(output.KeyMetadata, context) : undefined,
    };
};
const deserializeAws_json1_1DisabledException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1DisconnectCustomKeyStoreResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1EncryptionAlgorithmSpecList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1EncryptionContextType = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1EncryptResponse = (output, context) => {
    return {
        CiphertextBlob: output.CiphertextBlob != null ? context.base64Decoder(output.CiphertextBlob) : undefined,
        EncryptionAlgorithm: __expectString(output.EncryptionAlgorithm),
        KeyId: __expectString(output.KeyId),
    };
};
const deserializeAws_json1_1ExpiredImportTokenException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1GenerateDataKeyPairResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
        KeyPairSpec: __expectString(output.KeyPairSpec),
        PrivateKeyCiphertextBlob: output.PrivateKeyCiphertextBlob != null ? context.base64Decoder(output.PrivateKeyCiphertextBlob) : undefined,
        PrivateKeyPlaintext: output.PrivateKeyPlaintext != null ? context.base64Decoder(output.PrivateKeyPlaintext) : undefined,
        PublicKey: output.PublicKey != null ? context.base64Decoder(output.PublicKey) : undefined,
    };
};
const deserializeAws_json1_1GenerateDataKeyPairWithoutPlaintextResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
        KeyPairSpec: __expectString(output.KeyPairSpec),
        PrivateKeyCiphertextBlob: output.PrivateKeyCiphertextBlob != null ? context.base64Decoder(output.PrivateKeyCiphertextBlob) : undefined,
        PublicKey: output.PublicKey != null ? context.base64Decoder(output.PublicKey) : undefined,
    };
};
const deserializeAws_json1_1GenerateDataKeyResponse = (output, context) => {
    return {
        CiphertextBlob: output.CiphertextBlob != null ? context.base64Decoder(output.CiphertextBlob) : undefined,
        KeyId: __expectString(output.KeyId),
        Plaintext: output.Plaintext != null ? context.base64Decoder(output.Plaintext) : undefined,
    };
};
const deserializeAws_json1_1GenerateDataKeyWithoutPlaintextResponse = (output, context) => {
    return {
        CiphertextBlob: output.CiphertextBlob != null ? context.base64Decoder(output.CiphertextBlob) : undefined,
        KeyId: __expectString(output.KeyId),
    };
};
const deserializeAws_json1_1GenerateMacResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
        Mac: output.Mac != null ? context.base64Decoder(output.Mac) : undefined,
        MacAlgorithm: __expectString(output.MacAlgorithm),
    };
};
const deserializeAws_json1_1GenerateRandomResponse = (output, context) => {
    return {
        Plaintext: output.Plaintext != null ? context.base64Decoder(output.Plaintext) : undefined,
    };
};
const deserializeAws_json1_1GetKeyPolicyResponse = (output, context) => {
    return {
        Policy: __expectString(output.Policy),
    };
};
const deserializeAws_json1_1GetKeyRotationStatusResponse = (output, context) => {
    return {
        KeyRotationEnabled: __expectBoolean(output.KeyRotationEnabled),
    };
};
const deserializeAws_json1_1GetParametersForImportResponse = (output, context) => {
    return {
        ImportToken: output.ImportToken != null ? context.base64Decoder(output.ImportToken) : undefined,
        KeyId: __expectString(output.KeyId),
        ParametersValidTo: output.ParametersValidTo != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ParametersValidTo)))
            : undefined,
        PublicKey: output.PublicKey != null ? context.base64Decoder(output.PublicKey) : undefined,
    };
};
const deserializeAws_json1_1GetPublicKeyResponse = (output, context) => {
    return {
        CustomerMasterKeySpec: __expectString(output.CustomerMasterKeySpec),
        EncryptionAlgorithms: output.EncryptionAlgorithms != null
            ? deserializeAws_json1_1EncryptionAlgorithmSpecList(output.EncryptionAlgorithms, context)
            : undefined,
        KeyId: __expectString(output.KeyId),
        KeySpec: __expectString(output.KeySpec),
        KeyUsage: __expectString(output.KeyUsage),
        PublicKey: output.PublicKey != null ? context.base64Decoder(output.PublicKey) : undefined,
        SigningAlgorithms: output.SigningAlgorithms != null
            ? deserializeAws_json1_1SigningAlgorithmSpecList(output.SigningAlgorithms, context)
            : undefined,
    };
};
const deserializeAws_json1_1GrantConstraints = (output, context) => {
    return {
        EncryptionContextEquals: output.EncryptionContextEquals != null
            ? deserializeAws_json1_1EncryptionContextType(output.EncryptionContextEquals, context)
            : undefined,
        EncryptionContextSubset: output.EncryptionContextSubset != null
            ? deserializeAws_json1_1EncryptionContextType(output.EncryptionContextSubset, context)
            : undefined,
    };
};
const deserializeAws_json1_1GrantList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1GrantListEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GrantListEntry = (output, context) => {
    return {
        Constraints: output.Constraints != null ? deserializeAws_json1_1GrantConstraints(output.Constraints, context) : undefined,
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        GrantId: __expectString(output.GrantId),
        GranteePrincipal: __expectString(output.GranteePrincipal),
        IssuingAccount: __expectString(output.IssuingAccount),
        KeyId: __expectString(output.KeyId),
        Name: __expectString(output.Name),
        Operations: output.Operations != null ? deserializeAws_json1_1GrantOperationList(output.Operations, context) : undefined,
        RetiringPrincipal: __expectString(output.RetiringPrincipal),
    };
};
const deserializeAws_json1_1GrantOperationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1ImportKeyMaterialResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1IncorrectKeyException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1IncorrectKeyMaterialException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1IncorrectTrustAnchorException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidAliasNameException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidArnException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidCiphertextException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidGrantIdException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidGrantTokenException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidImportTokenException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidKeyUsageException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1InvalidMarkerException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1KeyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1KeyListEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1KeyListEntry = (output, context) => {
    return {
        KeyArn: __expectString(output.KeyArn),
        KeyId: __expectString(output.KeyId),
    };
};
const deserializeAws_json1_1KeyMetadata = (output, context) => {
    return {
        AWSAccountId: __expectString(output.AWSAccountId),
        Arn: __expectString(output.Arn),
        CloudHsmClusterId: __expectString(output.CloudHsmClusterId),
        CreationDate: output.CreationDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationDate)))
            : undefined,
        CustomKeyStoreId: __expectString(output.CustomKeyStoreId),
        CustomerMasterKeySpec: __expectString(output.CustomerMasterKeySpec),
        DeletionDate: output.DeletionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.DeletionDate)))
            : undefined,
        Description: __expectString(output.Description),
        Enabled: __expectBoolean(output.Enabled),
        EncryptionAlgorithms: output.EncryptionAlgorithms != null
            ? deserializeAws_json1_1EncryptionAlgorithmSpecList(output.EncryptionAlgorithms, context)
            : undefined,
        ExpirationModel: __expectString(output.ExpirationModel),
        KeyId: __expectString(output.KeyId),
        KeyManager: __expectString(output.KeyManager),
        KeySpec: __expectString(output.KeySpec),
        KeyState: __expectString(output.KeyState),
        KeyUsage: __expectString(output.KeyUsage),
        MacAlgorithms: output.MacAlgorithms != null
            ? deserializeAws_json1_1MacAlgorithmSpecList(output.MacAlgorithms, context)
            : undefined,
        MultiRegion: __expectBoolean(output.MultiRegion),
        MultiRegionConfiguration: output.MultiRegionConfiguration != null
            ? deserializeAws_json1_1MultiRegionConfiguration(output.MultiRegionConfiguration, context)
            : undefined,
        Origin: __expectString(output.Origin),
        PendingDeletionWindowInDays: __expectInt32(output.PendingDeletionWindowInDays),
        SigningAlgorithms: output.SigningAlgorithms != null
            ? deserializeAws_json1_1SigningAlgorithmSpecList(output.SigningAlgorithms, context)
            : undefined,
        ValidTo: output.ValidTo != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ValidTo))) : undefined,
        XksKeyConfiguration: output.XksKeyConfiguration != null
            ? deserializeAws_json1_1XksKeyConfigurationType(output.XksKeyConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_1KeyUnavailableException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1KMSInternalException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1KMSInvalidMacException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1KMSInvalidSignatureException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1KMSInvalidStateException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1LimitExceededException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1ListAliasesResponse = (output, context) => {
    return {
        Aliases: output.Aliases != null ? deserializeAws_json1_1AliasList(output.Aliases, context) : undefined,
        NextMarker: __expectString(output.NextMarker),
        Truncated: __expectBoolean(output.Truncated),
    };
};
const deserializeAws_json1_1ListGrantsResponse = (output, context) => {
    return {
        Grants: output.Grants != null ? deserializeAws_json1_1GrantList(output.Grants, context) : undefined,
        NextMarker: __expectString(output.NextMarker),
        Truncated: __expectBoolean(output.Truncated),
    };
};
const deserializeAws_json1_1ListKeyPoliciesResponse = (output, context) => {
    return {
        NextMarker: __expectString(output.NextMarker),
        PolicyNames: output.PolicyNames != null ? deserializeAws_json1_1PolicyNameList(output.PolicyNames, context) : undefined,
        Truncated: __expectBoolean(output.Truncated),
    };
};
const deserializeAws_json1_1ListKeysResponse = (output, context) => {
    return {
        Keys: output.Keys != null ? deserializeAws_json1_1KeyList(output.Keys, context) : undefined,
        NextMarker: __expectString(output.NextMarker),
        Truncated: __expectBoolean(output.Truncated),
    };
};
const deserializeAws_json1_1ListResourceTagsResponse = (output, context) => {
    return {
        NextMarker: __expectString(output.NextMarker),
        Tags: output.Tags != null ? deserializeAws_json1_1TagList(output.Tags, context) : undefined,
        Truncated: __expectBoolean(output.Truncated),
    };
};
const deserializeAws_json1_1MacAlgorithmSpecList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1MalformedPolicyDocumentException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1MultiRegionConfiguration = (output, context) => {
    return {
        MultiRegionKeyType: __expectString(output.MultiRegionKeyType),
        PrimaryKey: output.PrimaryKey != null ? deserializeAws_json1_1MultiRegionKey(output.PrimaryKey, context) : undefined,
        ReplicaKeys: output.ReplicaKeys != null ? deserializeAws_json1_1MultiRegionKeyList(output.ReplicaKeys, context) : undefined,
    };
};
const deserializeAws_json1_1MultiRegionKey = (output, context) => {
    return {
        Arn: __expectString(output.Arn),
        Region: __expectString(output.Region),
    };
};
const deserializeAws_json1_1MultiRegionKeyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MultiRegionKey(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1NotFoundException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1PolicyNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1ReEncryptResponse = (output, context) => {
    return {
        CiphertextBlob: output.CiphertextBlob != null ? context.base64Decoder(output.CiphertextBlob) : undefined,
        DestinationEncryptionAlgorithm: __expectString(output.DestinationEncryptionAlgorithm),
        KeyId: __expectString(output.KeyId),
        SourceEncryptionAlgorithm: __expectString(output.SourceEncryptionAlgorithm),
        SourceKeyId: __expectString(output.SourceKeyId),
    };
};
const deserializeAws_json1_1ReplicateKeyResponse = (output, context) => {
    return {
        ReplicaKeyMetadata: output.ReplicaKeyMetadata != null
            ? deserializeAws_json1_1KeyMetadata(output.ReplicaKeyMetadata, context)
            : undefined,
        ReplicaPolicy: __expectString(output.ReplicaPolicy),
        ReplicaTags: output.ReplicaTags != null ? deserializeAws_json1_1TagList(output.ReplicaTags, context) : undefined,
    };
};
const deserializeAws_json1_1ScheduleKeyDeletionResponse = (output, context) => {
    return {
        DeletionDate: output.DeletionDate != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.DeletionDate)))
            : undefined,
        KeyId: __expectString(output.KeyId),
        KeyState: __expectString(output.KeyState),
        PendingWindowInDays: __expectInt32(output.PendingWindowInDays),
    };
};
const deserializeAws_json1_1SigningAlgorithmSpecList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1SignResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
        Signature: output.Signature != null ? context.base64Decoder(output.Signature) : undefined,
        SigningAlgorithm: __expectString(output.SigningAlgorithm),
    };
};
const deserializeAws_json1_1Tag = (output, context) => {
    return {
        TagKey: __expectString(output.TagKey),
        TagValue: __expectString(output.TagValue),
    };
};
const deserializeAws_json1_1TagException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1UnsupportedOperationException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1UpdateCustomKeyStoreResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1VerifyMacResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
        MacAlgorithm: __expectString(output.MacAlgorithm),
        MacValid: __expectBoolean(output.MacValid),
    };
};
const deserializeAws_json1_1VerifyResponse = (output, context) => {
    return {
        KeyId: __expectString(output.KeyId),
        SignatureValid: __expectBoolean(output.SignatureValid),
        SigningAlgorithm: __expectString(output.SigningAlgorithm),
    };
};
const deserializeAws_json1_1XksKeyAlreadyInUseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksKeyConfigurationType = (output, context) => {
    return {
        Id: __expectString(output.Id),
    };
};
const deserializeAws_json1_1XksKeyInvalidConfigurationException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksKeyNotFoundException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyConfigurationType = (output, context) => {
    return {
        AccessKeyId: __expectString(output.AccessKeyId),
        Connectivity: __expectString(output.Connectivity),
        UriEndpoint: __expectString(output.UriEndpoint),
        UriPath: __expectString(output.UriPath),
        VpcEndpointServiceName: __expectString(output.VpcEndpointServiceName),
    };
};
const deserializeAws_json1_1XksProxyIncorrectAuthenticationCredentialException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyInvalidConfigurationException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyInvalidResponseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyUriEndpointInUseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyUriInUseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyUriUnreachableException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyVpcEndpointServiceInUseException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyVpcEndpointServiceInvalidConfigurationException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeAws_json1_1XksProxyVpcEndpointServiceNotFoundException = (output, context) => {
    return {
        message: __expectString(output.message),
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
